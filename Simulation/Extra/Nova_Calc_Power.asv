function [Power, next_charge] = Nova_Calc_Power(Params, theta_angle, current_charge, dt, Flags)
%--------------------------------------------------------------------------
% PURPOSE: This function calculates the total power available to charge the batteries, 
%          the state of charge of the batteries and the power produced by the solar panels
%--------------------------------------------------------------------------
% INPUT: Flags for day\nigth, Modes states, theta angle for power production calculations,
%        the current charge of the batteries, and time constant for next charge
%        calculation
%--------------------------------------------------------------------------
% OUTPUT: Total power, power production from the solar panels, 
%         and charge state of the batteries
%--------------------------------------------------------------------------

Day_state = Flags.IsDay;
Comm_state = Flags.Communication;

% according to the given state (day\night\modes), the relevant column from
% the power budget will be extracted for the power and charge calculations

if Day_state 
    Mode_data = Params.power_budget('Sun Cruise',:);

elseif Day_state && Comm_state
    Mode_data = Params.power_budget('Communication',:);

elseif not(Day_state) && Comm_state
    Mode_data = Params.power_budget('Communication',:); 

else 
    Mode_data = Params.power_budget('Night Cruise',:);
end

% switch Logic_state
% 
% 
%     case 'SafeMode'
%         if is_it_day
%             Mode_data = Params.power_budget('Sun Cruise',:);
%         else
%             Mode_data = Params.power_budget('Night Cruise',:);
%         end
% 
% 
%     case 'operational'
% 
%         switch Control_state
% 
%             case 'Communication'
%                 Mode_data = Params.power_budget('Communication',:);
% 
%             case 'GRB event'
%                 Mode_data = Params.power_budget('Payload_Mission',:);
% 
%             case 'Detumbling'
%                 Mode_data = Params.power_budget('Detumbling',:);
% 
%             case 'Commissioning'
%                 Mode_data = Params.power_budget('Commissioning',:);
% 
%             case 'Decomissioning'
%                 Mode_data = Params.power_budget('Decomissioning',:);
% 
%         end
% 
% end

for par = Params.power_budget.Properties.VariableNames
    Power.(char(par)) =  Mode_data(:,par).Variables;
end

% total power column from power budget 
power_consumption = Mode_data(:,'Total_Power').Variables;

% power production calculation

if Flags.IsDay
    Power_Production = Params.vertical_power_produc*abs(cos(theta_angle));
    Total_Power = Power_Production - power_consumption/60; %[w] Power available to charge the batteries

    current_charge_next = Total_Power*dt/3600;

    if current_charge + current_charge_next < Params.Max_capacity % check for overcharge
        next_charge = current_charge +  current_charge_next;
    else
    next_charge = Params.Max_capacity;
    end

else
    Power_Production = 0;
   if current_charge == Params.Max_capacity
    % if current_charge < 35
        Total_Power = 180 - power_consumption; %[w] Power available to charge the batteries
    else
         % Total_Power =current_charge/(dt/3600) - power_consumption; %[w] Power available to charge the batteries
         Total_Power =current_charge - power_consumption/60; %[w] Power available to charge the batteries

    end

    current_charge_next = Total_Power*dt/3600;

    if current_charge - current_charge_next < Params.Max_capacity % check for overcharge
        next_charge = current_charge -  current_charge_next;
    else
    next_charge = Params.Max_capacity;
    end

end

Power.Total_Power = Total_Power;
Power.Production  = Power_Production;
end

%%
numSteps=length(SimData.Angular_State.Psi;
figure
axis equal;
xlim([-1 1]);
ylim([-1 1]);
zlim([-1 1]);
xlabel('X');
ylabel('Y');
zlabel('Z');
hold on;

% Initialize quiver objects for the principal axes
hX = quiver3(0, 0, 0, 1, 0, 0, 'r', 'LineWidth', 2);
hY = quiver3(0, 0, 0, 0, 1, 0, 'g', 'LineWidth', 2);
hZ = quiver3(0, 0, 0, 0, 0, 1, 'b', 'LineWidth', 2);

% Loop to update the plot
for k = 1:numSteps
    % Compute the rotation matrix from Euler angles
    
    
    % Principal axes in the rotated frame
    xAxis = SimData.Angular_State.Psi(:);
    yAxis = SimData.Angular_State.Theta(:);
    zAxis = SimData.Angular_State.Phi(:);
    
    % Update the quiver objects
    set(hX, 'UData', xAxis(1), 'VData', xAxis(2), 'WData', xAxis(3));
    set(hY, 'UData', yAxis(1), 'VData', yAxis(2), 'WData', yAxis(3));
    set(hZ, 'UData', zAxis(1), 'VData', zAxis(2), 'WData', zAxis(3));
    
    drawnow;
end
